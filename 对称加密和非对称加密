对称加密和非对称加密的解释
两个人需要发送一些物品，为了防止别人拿到这些物品，就把这些物品放在了一个保险箱中，其中有保险箱有两部分组成：钥匙，带有锁的箱子.
1、对称加密相当于A和B两个人发送一些物品，首先A把这些物品（需要发送的数据）放在了保险箱（数据包）中，
然后在发送物品的时候就把保险箱上锁（相当于给数据加密），最后把保险箱（相当于加密后的数据）发送出去，同时B还要把钥匙（密钥）发送给A，
是为了让A打开保险箱（解密），查看里面的物品（查看内容）。
需要注意的一点是：在发送的过程中，如果有人同时得到了箱子和钥匙，那么里面的东西就相当的危险了。

这种方式，两方互相发送消息只需要一套密钥。
2、非对称加密：A和B两个人发送一些物品，如果A给B发送一些东西，那么B就要准备锁、钥匙和口令
（规定如果用口令对密码箱上锁，只能用钥匙打开箱子，如果用钥匙上的锁（钥匙也可以上锁的，有的锁没有钥匙是锁不住的，在九十年代的比较多），只能用口令解锁），
把其中的钥匙（口令也是可以的）发送给A，然后A就用钥匙（或者口令）给箱子上锁，然后把数据发送出去，那么在发送的过程中如果有人得到了保险箱，
没有钥匙还是得不到里面的东西，那么B得到箱子之后，就用口令（或者钥匙，就是用B没有发送出去的东西进行打开箱子，相当于解密）打开箱子（解密）拿到里面的东西。
注意：在发送的过程中即使有人得到了公用密钥和箱子，也是的不到里面的东西的（安全系数提高了），因为打开箱子的东西在B手中，就是A也是不知道的，
A就知道用B发送过来的东西，给箱子上锁，至于怎么打开那是B的事情。同样如果B需要给A发送一个东西，那么A也要给B提供一个给箱子上锁的方式（钥匙），
（上锁的方式是公开的，那么打开的方式就不是公开的，打开的方式只有发送上锁方式的发送方的手里有），然后利用这个方式（钥匙）上锁，得到箱子之后，
A用自己的其它方式（口令）打开箱子，得到内容。

这种方式如果两方互相发送消息，就要两套密钥，A给B发送消息，用B提供的公用密钥加密，B给A发送消息，用A提供的公用密钥加密。得到消息后，
用自己手中的私有密钥加密。


还有一点就是在学术上密钥分为私钥和公钥，私钥（只是起一个名字，也可以叫其他名字，例如:一个叫狗钥，一个叫猫钥，起名字只是为了区分两个密钥）
不一定是私有密钥，也可以是公有密钥。
私钥是公有密钥（大家都可以拥有）的话，那么公钥就是私有密钥（只能自己拥有的密钥），
相反如果私钥是私有密钥（大家都可以拥有）的话，那么公钥就是公有密钥（只能自己拥有的密钥）。


百度百科的解释
工作原理编辑
1.A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。
2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。
3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。
4.A将这个消息发给B（已经用B的公钥加密消息）。
5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。

主要应用编辑
非对称加密(公钥加密)：指加密和解密使用不同密钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，双方交换公钥，
使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。
假设A用B的公钥加密消息，用A的私钥签名，B接到消息后，首先用A的公钥验证签名，确认后用自己的私钥解密消息。由于公钥是可以公开的，
用户只要保管好自己的私钥即可，因此加密密钥的分发将变得 十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以通过信息发送者的
公钥来验证信息的来源是否真实，还可以通过数字签名确保发送者无法否认曾发送过该信息。非对称加密的缺点是加解密速度要远远慢于对称加密，
在某些极端情况下，甚至能比对称加密慢上1000倍。

RSACryptoServiceProvider
//加密
UnicodeEncoding encoding = new UnicodeEncoding();
byte[] PasswordBytes = encoding.GetBytes(password);
//将密码转换为字节数组RSACryptoServiceProvider crypt=new RSACryptoServiceProvider();
//RSA加密算法，非对称PasswordBytes=crypt.Encrypt(password ,false);//加密字节数组，这是加密后的密码值，放入数据库中的表字段中。
string key=crypt.ToXmlString(true);//输出密钥为XML格式的字符串，且包含私钥，这个字符串要作为数据库表中的一个字段同用户的密码放在一起。
//解密
RSACryptoServiceProvider crypt=new RSACryptoServiceProvider();//已随机生成了一个密钥对
crypt.Clear();//毁掉当前密钥对
crypt.FromXmlString(key)//输入密钥对，key是从数据库表字段中读取的那个XML格式的字符串，即密钥字段PasswordBytes=crypt.Decrypt(password ,false);
//解密字节数组，返回原始密码给用户
上面方法的一个特点是每个用户对应一个密钥（包含公钥和私钥），它们都是随机生成的，所以各不相同。不过缺点也是很明显的，就是密钥存储在数据库中，
如果数据库被攻破密钥就泄漏了。还有另外一个方法就是依照上面方法随机生成一个密钥对（包含公钥和私钥），通过ToXmlString(true)方法导出，
然后把这个XML字符串格式的密钥放到你的Web程序的Web.config文件的AppSetting节点里面，然后通过FromXmlString(key)方法读入密钥，
这样就意味着所有的用户密码都用同一个密钥对加密和解密。


主要算法编辑
RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。
使用最广泛的是RSA算法，Elgamal是另一种常用的非对称加密算法。
Elgamal由Taher Elgamal于1985年发明，其基础是DiffieˉHellman密钥交换算法，后者使通信双方能通过公开通信来推导出只有他们知道的秘密密钥值
[DiffieˉHellman]。DiffieˉHellman是Whitfield Diffie和Martin Hellman于1976年发明的，被视为第一种 非对称加密算法，DiffieˉHellman 
与RSA的不同之处在于，DiffieˉHellman不是加密算法，它只是生成可用作对称密钥的秘密数值。在DiffieˉHellman密钥交换过程中，发送方和接收方分别
生成一个秘密的随机数，并根据随机数推导出公开值，然后，双方再交换公开值。DiffieˉHellman算法的基础是具备生成共享密钥的能力。只要交换了公开值，
双方就能使用自己的私有数和对方的公开值来生成对称密钥，称为共享密钥，对双方来说，该对称密钥是相同的，可以用于使用对称加密算法加密数据。
与RSA相比，DiffieˉHellman的优势之一是每次交换密钥时都使用一组新值，而使用RSA算法时，如果攻击者获得了私钥，那么他不仅能解密之前截获的消息，
还能解密之后的所有消息。然而，RSA可以通过认证（如使用X.509数字证书）来防止中间人攻击，但Diff ieˉHellman在应对中间人攻击时非常脆弱。


算法区别编辑
非对称加密算法与对称加密算法的区别
首先，用于消息解密的密钥值与用于消息加密的密钥值不同;
其次，非对称加密算法比对称加密算法慢数千倍，但在保护通信安全方面，非对称加密算法却具有对称密码难以企及的优势。
为说明这种优势，使用对称加密算法的例子来强调：
Alice使用密钥K加密消息并将其发送给Bob，Bob收到加密的消息后，使用密钥K对其解密以恢复原始消息。这里存在一个问题，
即Alice如何将用于加密消息的密钥值发送给 Bob?答案是，Alice发送密钥值给Bob时必须通过独立的安全通信信道（即没人能监听到该信道中的通信）。
这种使用独立安全信道来交换对称加密算法密钥的需求会带来更多问题：
首先，有独立的安全信道，但是安全信道的带宽有限，不能直接用它发送原始消息。
其次，Alice和Bob不能确定他们的密钥值可以保持多久而不泄露（即不被其他人知道）以及何时交换新的密钥值
当然，这些问题不只Alice会遇到，Bob和其他每个人都会遇到，他们都需要交换密钥并处理这些密钥管理问题
（事实上，X9.17是一项DES密钥管理ANSI标准[ANSIX9.17]）。如果Alice要给数百人发送消息，那么事情将更麻烦，她必须使用不同的密
钥值来加密每条消息。例如，要给200个人发送通知，Alice需要加密消息200次，对每个接收方加密一次消息。显然，在这种情况下，
使用对称加密算法来进行安全通信的开销相当大。
非对称加密算法的主要优势就是使用两个而不是一个密钥值:一个密钥值用来加密消息，另一个密钥值用来解密消息。这两个密钥值在同一个过程中生成，
称为密钥对。用来加密消息的密钥称为公钥，用来解密消息的密钥称为私钥。用公钥加密的消息只能用与之对应的私钥来解密，
私钥除了持有者外无人知道，而公钥却可通过非安全管道来发送或在目录中发布。
Alice需要通过电子邮件给Bob发送一个机密文档。首先，Bob使用电子邮件将自己的公钥发送给Alice。
然后Alice用Bob的公钥对文档加密并通过电子邮件将加密消息发送给Bob。由于任何用Bob 的公钥加密的消息只能用Bob的私钥解密，因此即使窥探者知道Bob的公钥，
消息也仍是安全的。Bob在收到加密消息后，用自己的私钥进行解密从而恢复原始文档。
